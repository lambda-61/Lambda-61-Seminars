# FRP и бургеры

```
Дата:   10.04
Время:  19:00
Тема:   FRP: Behaviour vs Signal, Нуллабилити, DSL в Scala
Место:  Штефан Бургер, Соборный пер., 19
```

## FRP

Обсуждали различные подходы к функциональному реактивному программированию: Behaviour и Signal. В качестве примера Behaviour-подхода был назван обсуждавшийся на предыдущей встрече [Hoplon](https://github.com/hoplon/hoplon), в качестве примера из лагеря Signal - известная в Java мире FRP библиотека [RxJava](https://github.com/ReactiveX/RxJava).

_Прим. автора: если вы были на предыдущей встрече и тоже жалеете, что не хватило времени сравнить FRP с UDF, я нашел интересный короткий доклад [Hoplon and Javelin, WebDev Alternate Reality - Micha Niskin](https://youtu.be/UoZyyo2Bwr8), излагающий суть FRP подхода Hoplon в построении UI_

Разница между Behaviour и Signal довольно-таки тонкая. Signal предполагает поток сообщений во времени, накопление некоторого значения в промежутках между сообщениями возлагается на потребителя. Behaviour же всегда имеет некоторое значение, которое можно посмотреть в любой момент времени и подписаться на его изменения. Таким образом, Signal - это поток событий, диффов, Behaviour - это изменение значения во времени. Behaviour подход позволяет в языках с развитым метапрограммированием писать код в гораздо более декларативном стиле, чем Signal. Так или иначе, все FRP библиотеки, несмотря на приверженность одному из подходов чаще всего предоставляют инструменты для работы с другим.

_Прим. автора: если кому-то хочется погрузиться в научную сторону вопроса, [тут](http://conal.net/papers/icfp97/icfp97.pdf) можно найти один из самых ранних пейперов об FRP, где подробнее описаны Behavior и Signal_

## DSL

Когда упоминали dsl библиотеки Hoplon, зашла речь о принципах построения dsl в разных языках. Один из участников вспомнил статью [Зачем ЯОП? Зачем Racket?](https://habr.com/ru/post/445822/), но наш штатный лиспер не пришел на эту встречу, а сам предложивший о Racket только читал и еще смотрел доклад о языке Hackett [Hackett: a metaprogrammable Haskell by Alexis King](https://www.youtube.com/watch?v=5QQdI3P7MdY). Поэтому обсуждение быстро перекатилось на другую сторону фп, к TaglessFinal и Free Monads в Scala.

## TaglessFinal

## Free Monads

Когда слышишь Free, то понимаешь - ты свободен. Свободен делать с данными все, что захочешь. Free для моноидов - обычный список и ты можешь его свернуть любым другим моноидом по своим правилам. Также и Free Monads строят древовидную структуру данных, которую можно обойти своим интерпретатором для получения нужного результата. С помощью подмены или изменения интерпретатора можно тестировать код, добавлять логирование и выполнять другие манипуляции с контекстом без изменения описания логики работы программы.

_Прим. автора: для тех, кому не достаточно абстрактного объяснения - добро пожаловать в статью [Free Monoids and Free Monads, Free of Category Theory
](https://free.cofree.io/2017/12/27/free/) или, если совсем по хардкору, [в блог к Bartosz Milewski](https://bartoszmilewski.com/2015/07/21/free-monoids/)

## Nullability

В обсуждении также всплывала тема Maybe и ADT. Дело в том, что, как подметил Рич Хикки в своём докладе на ClojureConj ["Maybe Not"](https://www.youtube.com/watch?v=YR5WdGrpoug), a не является подтипом Maybe a. Из-за этого может сломаться обратная совместимость при облегчении, казалось бы, контракта API. Решением проблемы является введение настоящей суммы типов, [как в Dotty](https://dotty.epfl.ch/docs/reference/new-types/union-types.html) или в виде исключения для Optional типов, [как в Kotlin](https://kotlinlang.org/docs/reference/null-safety.html). В кложур собираются идти по другому пути, но какому - Рич еще не придумал.
